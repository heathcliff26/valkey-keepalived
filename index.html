
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/valkey-keepalived/pkg/cmd/root.go (28.6%)</option>
				
				<option value="file1">github.com/heathcliff26/valkey-keepalived/pkg/config/config.go (96.7%)</option>
				
				<option value="file2">github.com/heathcliff26/valkey-keepalived/pkg/failover-client/client.go (90.9%)</option>
				
				<option value="file3">github.com/heathcliff26/valkey-keepalived/pkg/failover-client/config.go (100.0%)</option>
				
				<option value="file4">github.com/heathcliff26/valkey-keepalived/pkg/failover-client/node.go (78.1%)</option>
				
				<option value="file5">github.com/heathcliff26/valkey-keepalived/pkg/failover-client/utils.go (75.0%)</option>
				
				<option value="file6">github.com/heathcliff26/valkey-keepalived/pkg/version/version.go (81.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "os"

        "github.com/heathcliff26/valkey-keepalived/pkg/config"
        failoverclient "github.com/heathcliff26/valkey-keepalived/pkg/failover-client"
        "github.com/heathcliff26/valkey-keepalived/pkg/version"
        "github.com/spf13/cobra"
)

const (
        flagNameConfig = "config"
        flagNameEnv    = "env"
)

func NewRootCommand() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return version.Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   version.Name,
                Short: version.Name + " failover a group of valkey databases based on a virtual ip",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        cfg, err := cmd.Flags().GetString(flagNameConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">env, err := cmd.Flags().GetBool(flagNameEnv)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return run(cfg, env)</span>
                },
        }

        <span class="cov8" title="1">rootCmd.Flags().StringP(flagNameConfig, "c", "", "Path to config file")
        err := rootCmd.MarkFlagFilename(flagNameConfig, "yaml", "yml")
        if err != nil </span><span class="cov0" title="0">{
                rootCmd.PrintErrln("Fatal: " + err.Error())
                os.Exit(1)
        }</span>

        <span class="cov8" title="1">rootCmd.Flags().Bool(flagNameEnv, false, "Expand enviroment variables in config file")

        rootCmd.AddCommand(
                version.NewCommand(),
        )

        return rootCmd</span>
}

func Execute() <span class="cov0" title="0">{
        cmd := NewRootCommand()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrln("Fatal: " + err.Error())
                os.Exit(1)
        }</span>
}

func run(configPath string, env bool) error <span class="cov0" title="0">{
        cfg, err := config.LoadConfig(configPath, env)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">failoverclient.NewFailoverClient(cfg.Valkey).Run()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "log/slog"
        "os"
        "strings"

        failoverclient "github.com/heathcliff26/valkey-keepalived/pkg/failover-client"
        "sigs.k8s.io/yaml"
)

const (
        DEFAULT_CONFIG_PATH = "/config/config.yaml"

        DEFAULT_LOG_LEVEL = "info"
        DEFAULT_PORT      = 6379
)

var logLevel *slog.LevelVar

// Initialize the logger
func init() <span class="cov8" title="1">{
        logLevel = &amp;slog.LevelVar{}
        opts := slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;opts))
        slog.SetDefault(logger)
}</span>

type Config struct {
        LogLevel string                      `json:"logLevel,omitempty"`
        Valkey   failoverclient.ValkeyConfig `json:"valkey"`
}

// Returns a Config with default values set
func DefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                LogLevel: DEFAULT_LOG_LEVEL,
                Valkey: failoverclient.ValkeyConfig{
                        Port: DEFAULT_PORT,
                },
        }
}</span>

// Loads config from file, returns error if config is invalid
// Arguments:
//
//        path: Path to config file
//        env: Determines if enviroment variables in the file will be expanded before decoding
func LoadConfig(path string, env bool) (Config, error) <span class="cov8" title="1">{
        c := DefaultConfig()

        if path == "" </span><span class="cov0" title="0">{
                path = DEFAULT_CONFIG_PATH
        }</span>

        <span class="cov8" title="1">f, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">if env </span><span class="cov8" title="1">{
                f = []byte(os.ExpandEnv(string(f)))
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(f, &amp;c)
        if err != nil </span><span class="cov8" title="1">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">err = setLogLevel(c.LogLevel)
        if err != nil </span><span class="cov8" title="1">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">err = c.Valkey.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

// Parse a given string and set the resulting log level
func setLogLevel(level string) error <span class="cov8" title="1">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov8" title="1">
                logLevel.Set(slog.LevelDebug)</span>
        case "info":<span class="cov8" title="1">
                logLevel.Set(slog.LevelInfo)</span>
        case "warn":<span class="cov8" title="1">
                logLevel.Set(slog.LevelWarn)</span>
        case "error":<span class="cov8" title="1">
                logLevel.Set(slog.LevelError)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unkown log level \"%s\"", strings.ToLower(level))</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package failoverclient

import (
        "context"
        "crypto/tls"
        "log/slog"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/valkey-io/valkey-go"
)

type FailoverClient struct {
        clientOption   valkey.ClientOption
        nodes          []*node
        virtualAddress string
        port           int64
        currentMaster  string
        masterAddr     string

        quit chan os.Signal
}

func NewFailoverClient(cfg ValkeyConfig) *FailoverClient <span class="cov8" title="1">{
        option := valkey.ClientOption{
                Username:     cfg.Username,
                Password:     cfg.Password,
                DisableCache: true,
                DisableRetry: true,
        }
        if cfg.TLS </span><span class="cov0" title="0">{
                option.TLSConfig = &amp;tls.Config{}
        }</span>

        <span class="cov8" title="1">nodes := make([]*node, len(cfg.Nodes))

        for i, addr := range cfg.Nodes </span><span class="cov8" title="1">{
                nodes[i] = &amp;node{
                        address: addr,
                        port:    cfg.Port,
                        up:      true,
                }
        }</span>

        <span class="cov8" title="1">return &amp;FailoverClient{
                clientOption:   option,
                nodes:          nodes,
                virtualAddress: cfg.VirtualAddress,
                port:           cfg.Port,
                quit:           make(chan os.Signal, 1),
        }</span>
}

func (c *FailoverClient) parallelJob(timeout time.Duration, f func(context.Context, *node)) <span class="cov8" title="1">{
        var wg sync.WaitGroup

        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        for _, n := range c.nodes </span><span class="cov8" title="1">{
                wg.Add(1)

                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()

                        f(ctx, n)
                }</span>()
        }

        <span class="cov8" title="1">wg.Wait()</span>
}

func (c *FailoverClient) updateNodes() <span class="cov8" title="1">{
        c.parallelJob(time.Second, func(ctx context.Context, n *node) </span><span class="cov8" title="1">{
                if n.client == nil </span><span class="cov8" title="1">{
                        err := n.connect(ctx, c.clientOption)
                        if err != nil </span><span class="cov8" title="1">{
                                if n.up </span><span class="cov8" title="1">{
                                        slog.Warn(failedToConnectToNodeMsg, slog.String("node", n.address), "err", err)
                                        n.up = false
                                }</span> else<span class="cov8" title="1"> {
                                        slog.Debug(failedToConnectToNodeMsg, slog.String("node", n.address), "err", err)
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }
                }

                <span class="cov8" title="1">n.ping(ctx)</span>
        })
}

func (c *FailoverClient) Run() <span class="cov8" title="1">{
        signal.Notify(c.quit, os.Interrupt, syscall.SIGTERM)

        firstTime := true

        slog.Info("Starting failover client")
        for </span><span class="cov8" title="1">{
                if !firstTime </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-c.quit:<span class="cov8" title="1">
                                slog.Info("Shutting down failover client")
                                return</span>
                        case &lt;-time.After(time.Second):<span class="cov8" title="1"></span>
                        }
                } else<span class="cov8" title="1"> {
                        firstTime = false
                }</span>

                <span class="cov8" title="1">c.updateNodes()

                client, err := newValkeyClient(c.virtualAddress, c.port, c.clientOption)
                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("Failed to connect to virtual address", slog.String("addr", c.virtualAddress), "err", err)
                        continue</span>
                }

                <span class="cov8" title="1">res, err := client.Do(context.Background(), client.B().Info().Section("server").Build()).ToString()
                client.Close()
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to retrieve info from virtual address", slog.String("addr", c.virtualAddress), "err", err)
                }</span>
                <span class="cov8" title="1">currentMaster := parseRunIDFromInfo(res)
                if currentMaster != c.currentMaster </span><span class="cov8" title="1">{
                        found := false
                        for _, n := range c.nodes </span><span class="cov8" title="1">{
                                if n.runID == currentMaster </span><span class="cov8" title="1">{
                                        c.currentMaster = currentMaster
                                        c.masterAddr = n.address
                                        found = true
                                }</span>
                        }
                        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                                slog.Error("Could not find the current masters addr", slog.String("run_id", currentMaster))
                                continue</span>
                        } else<span class="cov8" title="1"> {
                                slog.Info("Failing over to new master", slog.String("addr", c.masterAddr), slog.String("run_id", c.currentMaster))
                        }</span>
                }

                <span class="cov8" title="1">c.parallelJob(time.Second, func(ctx context.Context, n *node) </span><span class="cov8" title="1">{
                        if n.runID == c.currentMaster </span><span class="cov8" title="1">{
                                err := n.master(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Error("Failed to update node to master", slog.String("node", n.address), "err", err)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                err := n.slave(ctx, c.masterAddr)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Error("Failed to update node to slave", slog.String("node", n.address), "err", err)
                                }</span>
                        }
                })
        }
}

func (c *FailoverClient) Close() <span class="cov0" title="0">{
        for _, n := range c.nodes </span><span class="cov0" title="0">{
                n.close()
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package failoverclient

import "fmt"

type ValkeyConfig struct {
        VirtualAddress string   `json:"virtualAddress"`
        Port           int64    `json:"port,omitempty"`
        Nodes          []string `json:"nodes"`
        Username       string   `json:"username,omitempty"`
        Password       string   `json:"password,omitempty"`
        TLS            bool     `json:"tls,omitempty"`
}

func (c ValkeyConfig) Validate() error <span class="cov8" title="1">{
        if c.VirtualAddress == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("missing virtual address")
        }</span>
        <span class="cov8" title="1">if c.Port &lt; 0 || c.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid port, needs to be between 0-65535")
        }</span>
        <span class="cov8" title="1">if len(c.Nodes) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("need to have at least 1 node listed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package failoverclient

import (
        "context"
        "log/slog"

        "github.com/valkey-io/valkey-go"
)

type node struct {
        address string
        port    int64
        runID   string
        up      bool
        client  valkey.Client
}

const failedToConnectToNodeMsg = "Failed to connect to node"

func (n *node) connect(ctx context.Context, option valkey.ClientOption) error <span class="cov8" title="1">{
        client, err := newValkeyClient(n.address, n.port, option)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">res, err := client.Do(ctx, client.B().Info().Section("server").Build()).ToString()
        if err != nil </span><span class="cov8" title="1">{
                client.Close()
                return err
        }</span>

        <span class="cov8" title="1">n.runID = parseRunIDFromInfo(res)
        n.client = client
        n.up = true

        return nil</span>
}

func (n *node) ping(ctx context.Context) <span class="cov8" title="1">{
        res, err := n.client.Do(ctx, n.client.B().Ping().Build()).ToString()
        if err != nil || res != "PONG" </span><span class="cov8" title="1">{
                if n.up </span><span class="cov8" title="1">{
                        slog.Info("Node is DOWN", slog.String("node", n.address), "err", err, slog.String("res", res))
                        n.up = false
                }</span>
                <span class="cov8" title="1">n.client.Close()
                n.client = nil</span>
        } else<span class="cov8" title="1"> if !n.up </span><span class="cov0" title="0">{
                n.up = true
                slog.Info("Node is UP", slog.String("node", n.address))
        }</span>
}

func (n *node) master(ctx context.Context) error <span class="cov8" title="1">{
        if n.client == nil </span><span class="cov0" title="0">{
                slog.Debug("Node is not up, skipping for update", slog.String("node", n.address))
                return nil
        }</span>

        <span class="cov8" title="1">return n.client.Do(ctx, n.client.B().Replicaof().No().One().Build()).Error()</span>
}

func (n *node) slave(ctx context.Context, master string) error <span class="cov8" title="1">{
        if n.client == nil </span><span class="cov8" title="1">{
                slog.Debug("Node is not up, skipping for update", slog.String("node", n.address))
                return nil
        }</span>

        <span class="cov8" title="1">return n.client.Do(ctx, n.client.B().Replicaof().Host(master).Port(n.port).Build()).Error()</span>
}

func (n *node) close() <span class="cov0" title="0">{
        if n.client != nil </span><span class="cov0" title="0">{
                n.client.Close()
                n.client = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package failoverclient

import (
        "fmt"
        "log/slog"
        "strings"

        "github.com/valkey-io/valkey-go"
)

func newValkeyClient(addr string, port int64, option valkey.ClientOption) (valkey.Client, error) <span class="cov8" title="1">{
        option.InitAddress = []string{fmt.Sprintf("%s:%d", addr, port)}
        return valkey.NewClient(option)
}</span>

func ParseValueFromInfo(info string, key string) string <span class="cov8" title="1">{
        fields := strings.Split(info, "\r\n")

        for _, field := range fields </span><span class="cov8" title="1">{
                keyval := strings.SplitN(field, ":", 2)
                if len(keyval) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if keyval[0] == key </span><span class="cov8" title="1">{
                        return keyval[1]
                }</span>
        }

        <span class="cov0" title="0">slog.Error("Could not find the requested key in info", "info", info, "key", key)
        return ""</span>
}

func parseRunIDFromInfo(info string) string <span class="cov8" title="1">{
        return ParseValueFromInfo(info, "run_id")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package version

import (
        "runtime"
        "runtime/debug"

        "github.com/spf13/cobra"
)

const Name = "valkey-keepalived"

// Create a new version command with the given app name
func NewCommand() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information and exit",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        cmd.Print(VersionInfoString())
                }</span>,
        }
        // Override to prevent parent function from running
        <span class="cov8" title="1">cmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span>{<span class="cov0" title="0">}</span>

        <span class="cov8" title="1">return cmd</span>
}

// Return the version string
func Version() string <span class="cov8" title="1">{
        buildinfo, _ := debug.ReadBuildInfo()
        return buildinfo.Main.Version
}</span>

// Return a formated string containing the version, git commit and go version the app was compiled with.
func VersionInfoString() string <span class="cov8" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov8" title="1">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span> else<span class="cov8" title="1"> if commit == "" </span><span class="cov8" title="1">{
                commit = "Unknown"
        }</span>

        <span class="cov8" title="1">result := Name + ":\n"
        result += "    Version: " + buildinfo.Main.Version + "\n"
        result += "    Commit:  " + commit + "\n"
        result += "    Go:      " + runtime.Version() + "\n"

        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
